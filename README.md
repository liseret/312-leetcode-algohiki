## Задача - Burst Balloons (312 leetcode)

Даны n шариков, проиндексированных от 0 до n - 1. На каждом шарике есть число из массива nums.
Нужно лопнуть все шарики. Если вы лопаете $i-$й шарик, вы получите $nums[i-1]*nums[i+1]$ монет.
Если $i-1$ или $i+1$ выходят за границы массива, значит там находится шарик с единицей
Нужно вернуть максимальное количество монет, которое возможно собрать, грамотно лопая шарики

Оригинальное условие задачи с примерами:

<img width="1082" height="635" alt="image" src="https://github.com/user-attachments/assets/aa9892c5-73a3-4234-a409-75a435ad82ab" />


## Алгоритм

Задача о нахождении максимального количества монет при лопании шариков сводится к методу динамического програмирования, где мы определяем шарик, который будет лопнут в рассматриваемом интервале последним. 

Для начала выполняется подготовка входных данных: создается новый список, в который по краям добавляются элементы со значением 1 (границы), а также исключаются шарики с нулевой эффективностью, так как они не приносят прибыли.
Для каждого интервала $[start, end]$ производится поиск такого шарика $lastBurst$, взрыв которого в самом конце принесет самую большую выгоду, учитывая уже накопленные результаты для левого и правого под-интервалов.

## DP

dp[i][j] — это максимальное количество монет, которое можно получить, если лопнуть все шарики на отрезке от индекса i до j включительно. При расчете этого значения считается, что шарики слева от i (индекс $i-1$) и справа от j (индекс $j+1$) еще не лопнули.

База:
  1) start>end => 0 монет
  2) start == end => лопаем один шарик и его соседей соответственно

Переход - используется метод «Разделяй и властвуй». Для каждого интервала шариков $[start, end]$ мы по очереди представляем каждый шарик внутри него ($lastBurst$) как тот, который будет лопнут самым последним.

Порядок обхода - код идет от самого большого интервала (1, n) и рекурсивно разбиваем его на более мелкие интервалы. С помощью мемоизации, мы не считаем уже готовый интервал.

Ответ -ответ находится в dp[start][end], тк это итог всех поисков внутри интервала


Лемма 1. *Выбор шарика, который будет лопнут последним в текущем отрезке $[start, end]$, позволяет однозначно определить его соседей в момент взрыва.*

*Доказательство.* Предположим, что шарик с индексом $lastBurst$ лопается последним среди всех шариков в интервале от $start$ до $end$ включительно.
По определению «последнего», все остальные шарики внутри этого диапазона (слева от $lastBurst$ и справа от него) уже были лопнуты ранее.
Значит, в момент взрыва $lastBurst$ его ближайшими целыми соседями будут те шарики, которые стоят за границами текущего интервала, то есть шарики с индексами $start - 1$ и $end + 1$.
Это позволяет вычислить прибыль от этого конкретного шарика как произведение:
$$nums[start-1] \cdot nums[lastBurst] \cdot nums[end+1]$$

Лемма 2. *Оптимальное решение для интервала [start, end] может быть получено через решение независимых подзадач для интервалов [start, lastBurst-1] и [lastBurst+1, end].*

*Доказательство.* Так как шарик $lastBurst$ остается целым до самого конца, он служит своего рода «стеной», разделяющей левую и правую части (шарики в левой части при взрыве никак не могут взаимодействовать с шариками из правой части).
Таким образом, можно максимизировать прибыль для каждой стороны независимо и суммировать их с прибылью от финального взрыва шарика $lastBurst$.

Для реализации данного подхода используется рекурсивная функция с мемоизацией.
В начале работы создается таблица $dp$ размером $(n+1) \times (n+1)$, инициализированная значением $-1$.
При каждом вызове функции для интервала $[start, end]$ проверяется, не было ли это значение вычислено ранее.
В цикле перебираются все возможные кандидаты на роль последнего лопнутого шарика $lastBurst \in [start, end]$.
Для каждого варианта рассчитывается сумма монет, состоящая из произведения соседей и самого шарика, а также результатов рекурсивных вызовов для оставшихся частей.
Максимальное из полученных значений сохраняется в $dp$.

## Временная сложность — асимптотика

Сначала происходит подготовка списка $dp$ - линейное время ($O(n)$).
Основную нагрузку несет заполнение таблицы динамического программирования ($dp$). Количество различных состояний (интервалов $[start, end]$) в таблице ограничено величиной $O(n^2)$.
Для вычисления каждого такого состояния запускается цикл, проходящий по всем элементам текущего интервала, что в худшем случае дает $O(n)$ операций внутри каждого вызова функции.
Таким образом, общая временная сложность алгоритма составляет произведение количества состояний на сложность перехода между ними:
$$O(n^2) \cdot O(n) = O(n^3)$$
Где $n$ — количество шариков в исходном списке.

## Затраты памяти — асимптотика

Для работы алгоритма используется двумерный список $dp$ размером $n \times n$, где $n$ — количество шариков.
Это требует $O(n^2)$ дополнительной памяти для хранения промежуточных результатов (еще не забываем о глубине стека рекурсии, которая в худшем случае составляет $O(n)$.).
Но основной фактор использования памяти - таблица мемоизации, поэтому общие затраты по памяти оцениваются как:
$$O(n^2)$$
